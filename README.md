# Extinction-coefficient
Python program that can measure extinction using a list of frames
# Setting up
1) Use nova.astrometry.net site on your frames and save file with coordinates from there
2) Set the variable FOLDER in the 1st line of program to the path where the files is stored
3) Adjust other options
4) Run the program (hope that everything works)
# Code
Для начала задаются настройки {1} и импортируются пакеты {2}

Затем задается функция get_pixs {3}, переводящая массив экваториальных координат в позиции на снимке (если таковые имеются). Используются пакеты astropy.wcs и astropy.coordinates

Функция получает на вход массив из массивов, в которых на позиции index находится массив из двух чисел — склонение и прямое восхождение в градусах. Добавляет к каждому из вторичных массивов значение пикселя, на который ссылается координата.

Второе значение, получаемое на вход — открытый fits файл – файл обрабатываемого снимка, в котором содержатся значения описывающие наложенные координаты
Следующая задаваемая функция – download {4}. Она получает данные из каталога Yale bright stars и записывает их в dat файл.

Функция sort {5} выбирает из каталога, записанного в файл values.dat, звезды присутствующие на снимке. Это осуществляется за счет определения позиций центрального и крайнего пикселя картинки в экваториальных координатах и вычисление за счет этого радиуса области. В последствии, если звезда попадет в радиус области и ее звездная величина будет меньше заданной, она запишется в массив.

Функция dist {6}, использованная в sort для определения радиуса области, считает расстояние между координатами: это обсуждалось в разделе теории (см. п 1.2). Функция dtr {7} переводит градусы в радианы, что используется перед передачей склонения и прямого восхождения в функцию dist.

Позиции звезд и их блеск из каталога получены, для сравнения нужны позиции звезд на снимке и их звездные величины. Выполнить эту задачу возможно при помощи пакета photutils.detection и функции DAOStarFinder из него. Также, вернем значение стандартного отклонения и медианы — оно пригодится для этой же функции, в случае если обрабатывается несколько снимков. Выполнение реализует функция stars_finder {8}.

Получив массивы звезд и их позиций со звездными величинами, соберем все в один массив, сопоставив звезды на снимке со звездами из каталога. Для каждой звезды из каталога найдем ближайшую звезду со снимка если она находится ближ	е чем  FINDING_STARS_RANGE_LIMIT пикселей. Данное сопоставление выполняет функция match {9}. 

Функция air_masses {10} дает значение атмосферных масс в данных координатах. Для определения зенитного расстояния используется координаты зенита (звездное время и долгота местности) и координаты звезды.

Соберем перечисленные все функции в одну – main {11} функцию, последовательно выполняя их: получение звезд на снимке, получение каталога звезд, его фильтрация, получение позиций на снимке по координатам, возвращение сопоставления данных.

Основной цикл программы (функция loop {12}) для каждого файла находит measured_data (позиции и блеск звезд на снимке) используя функцию star_finder, при этом определяя стандартное отклонение лишь по первому снимку. Затем в функцию main передается открытый fits файл и measured_data. Формируется единый массив из полученных данных. Затем из массива удаляются выбросы и значения выводятся в виде графика (график без отбора выбросов представлен на рисунке 6).

Расчет медианного значения и стандартного отклонения реализован в функции calculate_mean_and_std {13}. Функция сортирует массив и берет его средний элемент – медиану. Затем через цикл получает сумму квадратов отклонений значений от медианы. И возвращает квадратный корень от суммы, деленной на количество элементов 

Удаление выбросов осуществляется в del_outliners {14} по сигма-каппа алгоритму, который был рассмотрен в п. 2.3. Значение каппа составляет 1.5.

Следующая функция plot {15} строит график зависимости и применяет линейную регрессию. Цель линейной регрессии — подбор таких значений k и b, чтобы сумма квадратов отклонений значений от прямой y = kx + b была минимальна. 

